module sage::term;

import std::interfaces;
import std::runtime::io;

// Terminal primitives: prefer stable runtime shims over hand-rolled termios
// layouts and ioctl constants.

export struct Size {
  rows: int,
  cols: int,
}

export fn size_default () -> Size {
  return Size{ rows: 24, cols: 80 };
}

export fn get_size (fd: int) -> Size {
  let packed: u64 = std::runtime::io::tty_winsize_packed(fd);
  if packed == 0 {
    return size_default();
  }
  let rows: int = (packed >> 32) as int;
  let cols: int = (packed & (0xFFFFFFFF as u64)) as int;
  if rows <= 0 || cols <= 0 {
    return size_default();
  }
  return Size{ rows: rows, cols: cols };
}

/**
 * A small RAII guard that switches a TTY into raw mode and restores it on drop.
 */
export struct RawMode {
  handle: u64,
  enabled: bool,
}

export fn raw_mode_enable (fd: int) -> RawMode? {
  let h_r = std::runtime::io::tty_raw_enter(fd);
  if h_r.is_err() {
    return None;
  }

  let h: u64 = match (h_r) { Ok(v) => v, Err(_) => 0 };
  if h == 0 {
    return None;
  }
  return Some(RawMode{ handle: h, enabled: true });
}

impl RawMode {
  public fn is_enabled (self: &RawMode) -> bool {
    return self.enabled;
  }

  public fn restore (mut self: &RawMode) -> void {
    if !self.enabled {
      return;
    }
    let _ = std::runtime::io::tty_raw_leave(self.handle);
    self.handle = 0;
    self.enabled = false;
  }
}

impl RawMode as std::interfaces::Drop {
  public fn drop (mut self: &RawMode) -> void {
    self.restore();
  }
}
