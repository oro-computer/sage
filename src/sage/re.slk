module sage::re;

import std::interfaces;
import std::result;
import std::runtime::mem;

// Small wrapper around the bundled runtime regex helpers (`libsilk_rt`).
//
// `sage` needs regex matching against arbitrary byte slices (mapped files), so
// it calls the runtime entry points directly rather than going through
// `std::regex` (which is string-oriented).

export const EXEC_MATCH: int = 1;
export const EXEC_NO_MATCH: int = 0;
export const EXEC_ERR_MEMORY: int = -1;
export const EXEC_ERR_TIMEOUT: int = -2;
export const EXEC_ERR_INVALID_INPUT: int = -3;

export struct ExecResult {
  // Use `sage::re::EXEC_*` constants.
  code: int,
  start: int,
  end: int,
}

export error CompileFailed {
  code: int,
}

type RegExpCompileResult = std::result::Result(RegExp, CompileFailed);

export struct RegExp {
  // Owned compiled bytecode (same layout as `SilkString`).
  ptr: u64,
  len: i64,
}

struct RtExecResult {
  code: i64,
  start: i64,
  end: i64,
}

struct RtCompileResult {
  code: i64,
  ptr: u64,
  len: i64,
}

ext silk_rt_regexp_exec = fn (u64, i64, u64, i64) -> RtExecResult;
ext silk_rt_regexp_compile = fn (u64, i64, u64, i64) -> RtCompileResult;
ext silk_rt_regexp_free = fn (u64, i64) -> void;

impl RegExp {
  public fn empty () -> RegExp {
    return RegExp{ ptr: 0, len: 0 };
  }

  public fn compile (pattern: string, flags: string) -> RegExpCompileResult {
    let pattern_ptr: u64 = std::runtime::mem::string_ptr(pattern);
    let pattern_len: i64 = std::runtime::mem::string_len(pattern);
    let flags_ptr: u64 = std::runtime::mem::string_ptr(flags);
    let flags_len: i64 = std::runtime::mem::string_len(flags);

    let r: RtCompileResult = silk_rt_regexp_compile(pattern_ptr, pattern_len, flags_ptr, flags_len);
    if r.code != 0 {
      return RegExpCompileResult.err(CompileFailed{ code: r.code as int });
    }
    return RegExpCompileResult.ok(RegExp{ ptr: r.ptr, len: r.len });
  }
}

impl RegExp as std::interfaces::Drop {
  public fn drop (mut self: &RegExp) -> void {
    if self.ptr != 0 {
      silk_rt_regexp_free(self.ptr, self.len);
    }
    self.ptr = 0;
    self.len = 0;
  }
}

export fn exec_bytes (re: &RegExp, input_ptr: u64, input_len: i64) -> ExecResult {
  let r: RtExecResult = silk_rt_regexp_exec(re.ptr, re.len, input_ptr, input_len);
  return ExecResult{ code: r.code as int, start: r.start as int, end: r.end as int };
}

export fn search_bytes (re: &RegExp, input_ptr: u64, input_len: i64, start: int) -> ExecResult {
  if input_ptr == 0 || input_len < 0 {
    return ExecResult{ code: EXEC_ERR_INVALID_INPUT, start: 0, end: 0 };
  }
  let start_i64: i64 = start as i64;
  if start_i64 < 0 || start_i64 > input_len {
    return ExecResult{ code: EXEC_ERR_INVALID_INPUT, start: 0, end: 0 };
  }

  let tail_ptr: u64 = input_ptr + (start_i64 as u64);
  let tail_len: i64 = input_len - start_i64;
  let r: ExecResult = exec_bytes(re, tail_ptr, tail_len);
  if r.code != EXEC_MATCH {
    return r;
  }
  return ExecResult{
    code: EXEC_MATCH,
    start: r.start + start,
    end: r.end + start,
  };
}
