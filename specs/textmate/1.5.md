# TextMate 1.x — Language Grammars (reference notes)

Source: `https://macromates.com/manual/en/language_grammars` (TextMate 1.x manual; page states it covers TextMate 1.5.1).

This file is a **paraphrased**, implementation-oriented summary. For authoritative wording and full examples, consult the source page.

## Scope of this document

This document summarizes what the TextMate 1.x manual page “Language Grammars” defines:

- The purpose of language grammars (scopes for syntax highlighting and editor behavior).
- The top-level grammar shape (`scopeName`, `fileTypes`, `patterns`, etc.).
- The rule model (`match` vs `begin`/`end`), capture naming, and `include`/`repository`.
- Scope naming conventions and common scope roots.

It does **not** attempt to fully specify:

- Property list serialization details (plist syntax variants, escaping rules, etc.).
- Scope selector syntax and matching rules.
- Regex engine flavor beyond the manual’s “single line at a time” constraint.
- The exact match selection/precedence algorithm when multiple rules could apply at a position (the manual page describes the rule primitives, not the full parser).

## What a language grammar does

- A grammar assigns **scope names** (dot-separated identifiers) to spans of text like keywords, comments, strings, etc.
- Scopes enable:
  - Syntax highlighting via themes.
  - Context-aware editor behavior (preferences, key bindings, tab triggers, spell-check toggles) via **scope selectors**.

## Grammar file shape (root keys)

TextMate grammars are stored as a property list (plist-style) dictionary. Common root-level keys:

- `scopeName`: unique scope for the language, usually `source.<lang>` for programming languages or `text.<type>` for markup/prose; specializations often derive from an existing base (e.g. `text.html.<variant>`).
- `fileTypes`: array of filename extensions used for auto-detection; user overrides via the status-bar language selector are remembered.
- `firstLineMatch` (optional): regex tested against the first line of a file for detection (e.g. shebang-based).
- `foldingStartMarker` / `foldingStopMarker`: regexes matched against individual lines to mark foldable regions. If a line matches one of the patterns (but not both), it becomes a folding marker.
- `patterns`: ordered array of rules that do the actual parsing/scoping.
- `repository` (optional): named rules you can `include` from multiple places (also useful for recursion).

## Rules: how matching works

Rules typically either:

1) Use `match` (a single regex): the match span gets scoped with the rule’s `name`.
2) Use `begin` + `end` (two regexes): the region from the `begin` match through the `end` match is scoped with `name`.
   - You can also add nested `patterns` to scope content inside the begin/end region.
   - If the `end` pattern never matches, the region extends to end-of-document.

Important constraint: **regexes are evaluated one line at a time**. You cannot write a single regex that matches across newlines; multi-line constructs are handled by placing `begin` and `end` on different lines, and then applying nested `patterns` line-by-line within that region.

## Common rule keys (cheat sheet)

- `name`: scope assigned to the matched region (or the whole begin/end region).
- `match`: regex used for single-shot matches.
- `begin`, `end`: regex pair for region matches (mutually exclusive with `match`).
  - Backreferences from `begin` can be used in `end` when supported by the regex engine.
- `contentName`: scope applied to the content **between** `begin` and `end` (excluding the delimiter matches).
- `patterns`: array of sub-rules applied to the interior of a begin/end region (or used at the top level).
- `captures`, `beginCaptures`, `endCaptures`: assign scopes to capture groups.
  - Value is a map from capture number (e.g. `1`, `2`, …) to `{ name = 'scope.name'; }`.
  - `captures` acts like “apply the same mapping” where appropriate; `beginCaptures`/`endCaptures` let you split it.
- `include`: pull in another rule set.
  - Include another language by scope: `include = "source.php"` (for embedded languages).
  - Include the current grammar: `include = "$self"`.
  - Include a named repository rule: `include = "#some-rule"`.

## Naming conventions (why they matter)

Scopes are technically free-form, but conventions make themes and editor behavior reusable across languages.

Practical guidelines:

- Don’t put everything under a single umbrella like `keyword.*`. Choose groups based on how you’d want it themed/handled.
- Reuse established sub-scope names where they exist (e.g. `storage.type` vs inventing `storage.kind`).
- Add specificity by appending segments (including the language) rather than creating entirely new branches.
- Put the language identifier last (`…<category>.<detail>.<language>`) so embedded-language cases can still target it reliably.

### Common top-level scope groups

Below are widely-used “root” scope prefixes and typical sub-categories.

- `comment`
  - `comment.line.<style>` (where `<style>` can reflect the delimiter: `double-slash`, `double-dash`, `number-sign`, `percentage`, etc.)
  - `comment.block` (optionally `comment.block.documentation`)
- `constant`
  - `constant.numeric`
  - `constant.character` (often `constant.character.escape`)
  - `constant.language` (built-in special values like booleans/null-ish)
  - `constant.other` (misc constants like CSS colors)
- `entity` (names/identifiers of larger structures)
  - `entity.name.function`, `entity.name.type`, `entity.name.tag`, `entity.name.section`
  - `entity.other.inherited-class`, `entity.other.attribute-name`
- `invalid`
  - `invalid.illegal`
  - `invalid.deprecated`
- `keyword`
  - `keyword.control`
  - `keyword.operator`
  - `keyword.other`
- `markup` (for markup/prose languages; often spans larger regions)
  - `markup.heading.<level>` (optionally)
  - `markup.bold`, `markup.italic`
  - `markup.underline` and `markup.underline.link`
  - `markup.list.numbered`, `markup.list.unnumbered`
  - `markup.quote`
  - `markup.raw` (verbatim/code; commonly disables spell-check)
- `meta` (context wrappers; often used in selectors rather than directly styled)
  - e.g. `meta.function`, `meta.interface`, `meta.implementation`, etc.
- `storage`
  - `storage.type`
  - `storage.modifier`
- `string`
  - `string.quoted.single`, `string.quoted.double`, `string.quoted.triple`, `string.quoted.other`
  - `string.unquoted` (here-docs/here-strings)
  - `string.interpolated` (evaluated strings)
  - `string.regexp`
- `support` (library/framework-provided identifiers)
  - `support.function`, `support.class`, `support.type`, `support.constant`, `support.variable`, `support.other`
- `variable`
  - `variable.parameter`
  - `variable.language` (reserved variables like “this/self/super”)
  - `variable.other`

## Quick implementation checklist

- Pick a `scopeName` that’s stable and composable (deriving from a base scope when specializing).
- Preserve rule order inside `patterns` (grammar authors expect rule arrays to be ordered, not sets).
- Use `repository` + `include` to avoid duplication and to handle recursive constructs.
- When you need “multi-line”, rely on `begin`/`end` regions; keep individual regexes single-line-friendly.
