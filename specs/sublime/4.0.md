# Sublime Text `.sublime-syntax` (Syntax Definitions) — Markdown Notes

Source: `https://www.sublimetext.com/docs/syntax.html` (reviewed on 2026-02-08)

This file is an opinionated **paraphrase / study guide** of the upstream documentation, converted into Markdown for easier local reference. It is not a verbatim copy.

---

## Overview

- `.sublime-syntax` files are YAML documents describing syntax highlighting rules.
- A syntax definition assigns **scopes** (e.g. `keyword.control.c`) to regions of text; color schemes map scopes to colors/styles.
- Each syntax defines a set of **contexts**, and highlighting proceeds by maintaining a **context stack**.
- A `main` context is required; it is the entrypoint when the syntax starts.
- `match` patterns use regular expressions based on the Oniguruma feature set (regex evaluation is performed line-by-line).
- Because the format is YAML, **tab characters are not allowed** inside `.sublime-syntax` files.

Minimal skeleton:

```yaml
%YAML 1.2
---
name: Example
file_extensions: [ex]
scope: source.example
version: 2

contexts:
  main:
    - match: '\b(example)\b'
      scope: keyword.control.example
```

---

## Header (Top-level keys)

The “header” is the top-level metadata that appears before `contexts:`.

- `name`: Display name in the menu. Optional; can be derived from the filename.
- `file_extensions`: List of extensions (or full filenames like `.gitignore`) associated with the syntax.
- `hidden_file_extensions`: Like `file_extensions`, but not shown in OS file dialogs.
- `first_line_match`: Regex tested against the first line when the filename/extension is not conclusive.
- `scope`: Default scope for the whole file (base scope).
- `version`: Compatibility gate (`1` or `2`). Omitted means version 1; new syntaxes should generally target version 2.
- `extends`: Inherit from another syntax (package path such as `Packages/JavaScript/JavaScript.sublime-syntax`). See [Inheritance](#inheritance).
- `hidden`: If true, the syntax won’t show in menus, but can still be set by plugins or included by other syntaxes.

---

## Contexts

A context is a named list of patterns. Patterns run in order, and the engine selects:

- the **leftmost** match on the line, and
- if multiple patterns match at the same position, the **earliest-defined** pattern wins.

In practice you create multiple contexts to avoid matching tokens in the wrong region (e.g., keywords inside strings).

### Meta patterns (context-wide settings)

Meta patterns apply to the whole context and **must come first** in the context’s list.

- `meta_scope`: Adds a scope to *everything* while the context is on the stack, including the delimiters that pushed/popped the context.
- `meta_content_scope`: Like `meta_scope`, but excludes the text that caused entry/exit (useful for quoting/brace delimiters).
- `meta_include_prototype`: When set to `false`, prevents automatic inclusion of the `prototype` context (see below).
- `clear_scopes`: Removes scope names from the current stack before applying meta scopes. Accepts an integer (remove that many) or `true` (remove all). Commonly used while embedding another syntax.
- `meta_prepend` / `meta_append`: In an inheriting syntax, control how a context with the same name is merged with its parent (prepend/append patterns instead of overriding). See [Inheritance](#inheritance).

### Match patterns (regex-driven rules)

A match pattern is a mapping with some combination of these keys:

- `match` (required): The regex. YAML quoting rules apply; if the regex contains YAML-significant characters (e.g. `#`, `:`, `{`, `[`), quoting is often safest.
- `scope`: Scope applied to the full match.
- `captures`: Map capture group numbers to scopes (use `0` for “entire match” when applicable).

Actions (control the context stack). A match pattern generally specifies **one** of these primary actions:

- `push`: Push one or more contexts. Supports:
  - a single context name,
  - a list of context names (rightmost becomes the top of the stack),
  - an inline anonymous context (for small one-off sequences),
  - a different syntax via package path or `scope:...` (see [Including other files](#including-other-files)).
- `set`: Replace the current context (pop current, then push the new one(s)).
  - The triggering match is scoped as if it belongs to both the popped context and the pushed context (re: `meta_scope`).
- `embed`: Enter an embedded context until an `escape` pattern is seen (useful for embedding one language inside another).
  - `embed` accepts a single target (context name or external syntax reference).
  - Unlike a plain `push`, `embed` exits as soon as `escape` is found, even if the embedded syntax pushed further nested contexts.
  - `escape` (required with `embed`): Regex that exits the embedded context.
    - Backreferences in `escape` refer to capture groups from the `match` regex.
  - `embed_scope`: Scope applied to the embedded region (between `match` and `escape`), similar in spirit to `meta_content_scope`.
  - `escape_captures`: Capture-group scope mapping for the `escape` match.
- `branch`: Attempt multiple alternative contexts in order (useful for ambiguous constructs). Used with:
  - `branch_point`: Identifier for where to rewind to.
  - `fail`: Trigger a rewind to a given `branch_point` and retry using the next branch target.

`pop` is also an action:

- `pop`: Pop contexts off the stack.
  - `true` pops one context.
  - An integer `N` pops `N` contexts.
  - In newer Sublime builds, `pop` may be combined with `push`, `set`, `embed` or `branch` to pop first, then perform the other action.
  - When combined with `push`, `embed` or `branch`, the match behaves like a lookahead for scoping purposes (it won’t pick up `meta_scope` from the contexts that were popped).

### Include patterns (reusing pattern lists)

Use `include` to splice the patterns from another context at the include position:

```yaml
contexts:
  expr:
    - include: comments
    - match: '\b\d+\b'
      scope: constant.numeric.example
```

Notes:

- `include` brings in **match** and **include** patterns from the target context.
- Meta patterns from the included context are ignored (meta patterns must be defined directly in the current context).

#### Including an external prototype

When including contexts from *another* syntax, you can opt into bringing along that syntax’s prototype by adding:

```yaml
- include: scope:source.html.basic
  apply_prototype: true
```

This applies only when the target syntax defines `prototype` and the current context hasn’t opted out via `meta_include_prototype: false`.

### Prototype context

If you define a context named `prototype`, Sublime will automatically include it at the top of every other context.

- Use this for patterns you want almost everywhere (especially comments).
- Opt out per-context with `meta_include_prototype: false`.

---

## Including Other Files

Sublime Syntax supports embedding one syntax inside another.

Common patterns:

- **Outer language embeds inner language** (e.g., HTML embeds JavaScript):
  - Push the other syntax (by package path) when a delimiter is seen.
  - Use `with_prototype` to inject “exit” logic into *every* context of the pushed syntax (often implemented as a lookahead that pops when the closing delimiter is coming).

- **Template language wraps a base language** (e.g., templating “defaults to HTML” but occasionally escapes):
  - Push the base syntax immediately using a zero-width match (`match: ''`).
  - Inject the template delimiters via `with_prototype` so they are recognized from anywhere inside the base syntax.

Important limitation called out in the docs:

- You can’t include a `.tmLanguage` file *from* a `.sublime-syntax` file (even though Sublime Text can use both formats).

---

## Variables

Top-level `variables:` lets you reuse regex fragments:

```yaml
variables:
  ident: '[A-Za-z_][A-Za-z_0-9]*'

contexts:
  main:
    - match: '\b{{ident}}\b'
      scope: variable.other.example
```

Key points:

- Variables are only defined at the top level.
- Use `{{var_name}}` inside regex strings.
- Variables can reference other variables.
- Only placeholders matching `{{[A-Za-z0-9_]+}}` are considered variables; other `{{` text can be used literally in regexes.
- Substitution happens after variables are fully realized, so overriding an inherited variable affects how parent contexts expand it.

---

## Inheritance

Inheritance is for “variant” syntaxes that mostly build on an existing syntax.

### Basic inheritance (`extends`)

Use `extends:` to name a parent syntax by package path:

```yaml
extends: Packages/C++/C.sublime-syntax
```

Only these top-level keys are inherited:

- `variables`
- `contexts`

Other header metadata (like `scope`, `file_extensions`, etc.) is *not* inherited.

### Variable inheritance

- Parent and child `variables` mappings are merged.
- Child variables with the same name override the parent value.
- Variable expansion is applied after the final merged variable mapping is known.

### Context inheritance

- Parent and child `contexts` are combined.
- A child context with the same name normally **replaces** the parent context.
- To merge instead, add `meta_prepend: true` or `meta_append: true` as the first entry of the child context.

### Multiple inheritance

- `extends` may be a list of two or more parents.
- Parents are processed top-to-bottom.
- Parents must share a common base and must target the same syntax `version`.

---

## Selected examples (concepts)

The upstream doc includes examples showing patterns you may want to apply:

- **Bracket balancing**: mark closing delimiters as invalid when not currently inside the matching “open” context.
- **Sequential contexts**: walk through a construct in phases by `set`-ting a new context as you see each delimiter/token (e.g., validating a `for (...)` layout).
- **Advanced stack usage**: push multiple contexts at once so one context consumes a sub-structure and pops, leaving another “next step” context on top.
- **Backreferences across contexts**: capture something in the `match` regex and use it later in another context (e.g., heredoc terminators) via `\1`, `\2`, etc.

---

## Testing

Instead of manually inspecting scopes during development, syntax tests provide a repeatable check.

### Creating a syntax test file

Rules summarized from the doc:

- Filename starts with `syntax_test_`.
- Save the file somewhere under the `Packages/` directory (often next to the syntax).
- First line declares the syntax under test:
  - `<comment_token> SYNTAX TEST "<syntax_path>"`
  - You can also reference a `.tmLanguage` syntax here.

### Running tests

- Run Sublime’s `build` command while a syntax test or the syntax file is active.
- Use “Next Result” (F4) to jump to failures.

### Assertion types

Each assertion line starts with the same comment token, then one of:

- `^` (caret test): checks a selector at a specific column on the most recent non-test line (multiple `^` check multiple columns).
- `<-` (arrow test): checks a selector at the column where the comment starts on the most recent non-test line.
- `@` (symbol test): checks symbol classification for the annotated text. The docs list: `none`, `local-definition`, `global-definition`, `definition`, `reference`.

### Test options

Options appear after `SYNTAX TEST` on the first line:

- `partial-symbols`: don’t require exhaustively annotating all symbols when `@` tests are present.
- `reindent-unchanged`: ensure reindent leaves the file unchanged.
- `reindent-unindented`: ensure reindent can reconstruct the file after removing indentation.
- `reindent`: shorthand for both reindent checks.

---

## Compatibility (Syntax `version` 1 vs 2)

Breaking/high-impact changes in syntax behavior are gated behind `version:`.

- Missing `version` ⇒ version 1 behavior.
- `version: 2` enables fixes/changes; the upstream doc provides concrete examples.

High-level takeaways from the listed differences:

- `embed_scope` interaction: version 1 may combine `embed_scope` with the embedded syntax’s `scope` in cases where version 2 won’t.
- `set` and meta scoping: version 1 can incorrectly apply `meta_content_scope` from the popped context when using `set`.
- `clear_scopes` edge cases: version 1 has known issues when `set` targets contexts with `clear_scopes`, and when pushing multiple targets that each clear scopes.
- `embed` escape scoping: version 1 may fail to apply surrounding meta scopes to text matched by the `escape` regex.
- Capture ordering: version 1 can fail to apply capture scopes when lower-numbered capture groups match text later than higher-numbered groups.
