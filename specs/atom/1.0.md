# Atom `.cson` grammars (TextMate-style) — reference notes

Source notes:
- Atom grammars are typically TextMate-style rule sets stored as CSON (CoffeeScript Object Notation).
- This doc is a paraphrased, implementation-oriented summary plus notes about `sage`’s supported subset.

Reviewed: 2026-02-09

---

## What an Atom grammar is (high level)

An Atom grammar assigns **scope names** (dot-separated identifiers like `keyword.control.js`) to regions of text.
Themes map these scopes to colors/styles.

Most Atom grammars follow the TextMate 1.x model:
- `patterns`: ordered list of rules
- `repository`: named rule groups referenced via `include`
- rule objects usually use either:
  - `match` + `name` (single regex), or
  - `begin` + `end` + `name` (region rules, often with nested `patterns`)

## Common root keys

Typical top-level keys in a grammar:
- `scopeName`: the canonical scope for the language (e.g. `source.js`)
- `name`: display name (e.g. `JavaScript`)
- `fileTypes`: array of extensions (e.g. `["js", "jsx"]`)
- `patterns`: array of rule objects
- `repository`: map of named rule objects used by `include: "#name"`

Some files wrap the grammar under a top-level key like `'.source.js': ...`. In that case the same keys appear inside the nested object.

## CSON essentials (subset)

CSON is “JSON-like”, with CoffeeScript conveniences:
- Keys may be unquoted identifiers (`fileTypes:`) or quoted strings (`'fileTypes':`).
- Strings are usually single-quoted or double-quoted (backslash escapes are supported).
- Arrays use `[...]`; commas are often optional; trailing commas are often accepted.
- Objects may be written with `{ ... }` braces **or** as indentation blocks after `key:`.
- Line comments commonly use `#` or `//`.

## Rule objects (what matters for highlighting)

The most common patterns you’ll see:

### `match` rule

```cson
{
  match: '\\b(function|class)\\b'
  name: 'keyword.control.js'
}
```

### `begin`/`end` rule (region-based)

```cson
{
  begin: '/\\*'
  end: '\\*/'
  name: 'comment.block.js'
  patterns: [ ... ]
}
```

### `include` (reuse)

```cson
{ include: '#comments' }
```

## `sage` support (current subset)

`sage --compile-cache` reads syntax sources from:
- `XDG_CONFIG_HOME/sage/syntax/` (default: `~/.config/sage/syntax/`)

and writes compiled caches to:
- `XDG_CACHE_HOME/sage/syntax/` (default: `~/.cache/sage/syntax/`)

Supported CSON subset:
- Files ending in `.cson` are treated as Atom grammars.
- `fileTypes` is parsed as an array of strings; values become extension keys (lowercased).
- Both common object styles are handled:
  - indentation blocks (`key:` followed by indented `match:` / `name:` lines), and
  - inline brace objects (`{ match: '...', name: '...' }`), including multiple `key: value` pairs per line.
- Rule extraction:
  - `match` + `name` inside an object produces one regex rule.
  - `begin` + `end` + `name` are *partially* supported:
    - `sage` does not build a full TextMate-style push/pop state machine.
    - Instead, it recognizes a small set of “simple delimiter” ranges and records them as **range flags** in the compiled cache:
      - line comments: `// ...` (when `end` is `\n` or `$`)
      - block comments: `/* ... */`
      - strings: `'...'`, `"..."`, and `` `...` ``
    - At runtime these flags enable **stateful range highlighting** across wrapped viewport segments, preventing keyword/type/operator regex rules from firing inside strings/comments.
  - Other TextMate/Atom features are still ignored during compilation (e.g. `captures`, nested `patterns` semantics, `include`/`repository` recursion).

Practical consequence:
- Grammars that rely heavily on `begin`/`end` will still *not* get full-fidelity context parsing, but `sage` can now correctly paint the most common multi-line comment/string ranges and keep that state coherent across wraps.

## `--compile-cache` scanning

- Syntax sources under `XDG_CONFIG_HOME/sage/syntax/` are scanned **recursively**.
- Compiled caches are written flat into `XDG_CACHE_HOME/sage/syntax/` using a stable name derived from the relative path:
  - `atom/javascript.cson` → `atom_javascript.sagec`
  - `textmate/c.tmLanguage` → `textmate_c.sagec`

## Notes on the bundled example (`syntax/atom/javascript.cson`)

`syntax/atom/javascript.cson` is a small JavaScript grammar meant as:
- a readable example of Atom/CSON structure, and
- a stable fixture for `sage`’s CSON parser behavior (fileTypes + `match`/`name` rules).
